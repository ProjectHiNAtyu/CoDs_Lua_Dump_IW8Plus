-- Generated by CoDLuaDecompiler
-- Version: 2.4.2
-- Date: 04-10-2025 21:43
TIME = {
	Format = {
		STOPWATCH = 3,
		READABLE = 1,
		STOPWATCH_MINIMAL = 4,
		READABLE_MINIMAL = 2
	}
}
local f0_local0 = {
	nil,
	"millisecond",
	"second",
	"minute",
	"hour",
	"day"
}
local f0_local1 = {
	nil,
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
}
local f0_local2 = {
	millisecond = {
		milliseconds = 1,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/MILLISECOND_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/MILLISECOND" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/MILLISECOND_PLURAL" )
	},
	second = {
		milliseconds = 1000,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/SECOND_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/SECOND" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/SECOND_PLURAL" )
	},
	minute = {
		milliseconds = 60000,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/MINUTE_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/MINUTE" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/MINUTE_PLURAL" )
	},
	hour = {
		milliseconds = 3600000,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/HOUR_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/HOUR" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/HOUR_PLURAL" )
	},
	day = {
		milliseconds = 86400000,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/DAY_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/DAY" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/DAY_PLURAL" )
	},
	day = {
		milliseconds = 604800000,
		smallName = Engine[0xED84C33EC5F01EA]( "TIME/WEEK_MINIMAL" ),
		longName = Engine[0xED84C33EC5F01EA]( "TIME/WEEK" ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( "TIME/WEEK_PLURAL" )
	}
}
local f0_local3 = function ( f7_arg0, f7_arg1 )
	local f7_local0 = {}
	for f7_local1 = #f0_local0, 1, -1 do
		local f7_local4 = f0_local0[f7_local1]
		local f7_local5 = f7_arg1[f7_local4]
		if f7_local5 ~= nil then
			local f7_local6 = f0_local0[f7_local4]
			local f7_local7 = math.floor( f7_arg0 / f7_local6.milliseconds )
			f7_arg0 = f7_arg0 - f7_local7 * f7_local6.milliseconds
			if 0 < f7_local7 or f7_local5 == false then
				f7_local0[f7_local4] = f7_local7
			end
		end
	end
	return f7_local0
end

local f0_local4 = function ( f6_arg0, f6_arg1 )
	local f6_local0 = f0_local0( f6_arg0, f6_arg1 )
	local f6_local1 = ""
	local f6_local2 = {}
	local f6_local3 = CONDITIONS.IsArabic( nil )
	local f6_local4
	if f6_local3 then
		f6_local4 = f0_local0
		if not f6_local4 then
		
		else
			for f6_local5 = #f6_local4, 1, -1 do
				local f6_local8 = f6_local4[f6_local5]
				local f6_local9 = f6_local0[f6_local8]
				if f6_local9 then
					local f6_local10 = nil
					if f6_local3 then
						f6_local10 = string.format( "%s %d", 1 and f0_local0[f6_local8].longNamePlural or f0_local0[f6_local8].longName, f6_local9 )
					else
						f6_local10 = string.format( "%d %s", f6_local9, 1 and f0_local0[f6_local8].longNamePlural or f0_local0[f6_local8].longName )
					end
					table.insert( f6_local2, f6_local10 )
					f6_local1 = f6_local1 .. "%s "
				end
			end
			local f6_local5 = string.format
			local f6_local7 = f6_local1
			return f6_local5( unpack( f6_local2 ) )
		end
	end
	f6_local4 = f0_local0
end

local f0_local5 = function ( f5_arg0, f5_arg1 )
	local f5_local0 = f0_local0( f5_arg0, f5_arg1 )
	local f5_local1 = ""
	local f5_local2 = {}
	local f5_local3 = CONDITIONS.IsArabic( nil )
	local f5_local4
	if f5_local3 then
		f5_local4 = f0_local0
		if not f5_local4 then
		
		else
			for f5_local5 = #f5_local4, 1, -1 do
				local f5_local8 = f5_local4[f5_local5]
				local f5_local9 = f5_local0[f5_local8]
				if f5_local9 then
					local f5_local10 = nil
					if f5_local3 then
						f5_local10 = string.format( "%s%d", f0_local0[f5_local8].smallName, f5_local9 )
					else
						f5_local10 = string.format( "%d%s", f5_local9, f0_local0[f5_local8].smallName )
					end
					table.insert( f5_local2, f5_local10 )
					f5_local1 = f5_local1 .. "%s "
				end
			end
			local f5_local5 = string.format
			local f5_local7 = f5_local1
			return f5_local5( unpack( f5_local2 ) )
		end
	end
	f5_local4 = f0_local0
end

local f0_local6 = function ( f4_arg0 )
	return string.format( "%01d:%02d.%01d", f4_arg0 / 60000, f4_arg0 / 1000 % 60, f4_arg0 % 1000 / 100 )
end

local f0_local7 = function ( f3_arg0 )
	return string.format( "%01d:%02d", f3_arg0 / 60000, f3_arg0 / 1000 % 60 )
end

TIME.FormatSeconds = function ( f2_arg0, f2_arg1, f2_arg2 )
	if not f2_arg2 then
		f2_arg2 = {
			minute = false,
			second = false
		}
	end
	if f2_arg1 == TIME.Format.READABLE then
		return f0_local0( f2_arg0 * 1000, f2_arg2 )
	elseif f2_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f2_arg0 * 1000, f2_arg2 )
	elseif f2_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f2_arg0 * 1000 )
	elseif f2_arg1 == TIME.Format.STOPWATCH_MINIMAL then
		return f0_local0( f2_arg0 * 1000 )
	else
		assert( false, "Invalid time format provided to TIME.FormatSeconds" )
	end
end

TIME.FormatMilliseconds = function ( f1_arg0, f1_arg1, f1_arg2 )
	if not f1_arg2 then
		f1_arg2 = {
			minute = false,
			second = false
		}
	end
	if f1_arg1 == TIME.Format.READABLE then
		return f0_local0( f1_arg0, f1_arg2 )
	elseif f1_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f1_arg0, f1_arg2 )
	elseif f1_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f1_arg0 )
	elseif f1_arg1 == TIME.Format.STOPWATCH_MINIMAL then
		return f0_local0( f1_arg0 )
	else
		assert( false, "Invalid time format provided to TIME.FormatMilliseconds" )
	end
end

