-- Generated by CoDLuaDecompiler
-- Version: 2.4.2
-- Date: 13-10-2025 14:16
TIME = {
	Format = {
		STOPWATCH_MINIMAL = 5,
		STOPWATCH = 3,
		CLOCK = 4,
		READABLE_MINIMAL = 2,
		CLOCK_MINIMAL = 6,
		READABLE = 1
	}
}
local f0_local0 = {
	nil,
	"millisecond",
	"second",
	"minute",
	"hour",
	"day"
}
local f0_local1 = {
	nil,
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
}
TIME.SECOND = 1
TIME.MINUTE = TIME.SECOND * 60
TIME.HOUR = TIME.MINUTE * 60
TIME.DAY = TIME.HOUR * 24
TIME.SECOND_IN_MS = TIME.SECOND * 1000
TIME.MINUTE_IN_MS = TIME.SECOND_IN_MS * 60
TIME.HOUR_IN_MS = TIME.MINUTE_IN_MS * 60
TIME.DAY_IN_MS = TIME.HOUR_IN_MS * 24
TIME.TimeFields = {
	millisecond = {
		milliseconds = 1,
		smallName = Engine[0xED84C33EC5F01EA]( 0x4A4799F6B0D01A9 ),
		longName = Engine[0xED84C33EC5F01EA]( 0xA24A3441DF9C05D ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( 0xF4E035568D2E178 )
	},
	second = {
		milliseconds = 1000,
		smallName = Engine[0xED84C33EC5F01EA]( 0xE03D53A45EE68C0 ),
		longName = Engine[0xED84C33EC5F01EA]( 0xA28AA7CA633A168 ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( 0xB2EFF8B5C6D511F )
	},
	minute = {
		milliseconds = 60000,
		smallName = Engine[0xED84C33EC5F01EA]( 0xD91D8C94318FD8C ),
		longName = Engine[0xED84C33EC5F01EA]( 0x1EB953B6A2D84FC ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( 0x59DAD57D92555EB )
	},
	hour = {
		milliseconds = 3600000,
		smallName = Engine[0xED84C33EC5F01EA]( 0x6452C0517412802 ),
		longName = Engine[0xED84C33EC5F01EA]( 0x3487560E11A2532 ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( 0xF03759711628CD5 )
	},
	day = {
		milliseconds = 86400000,
		smallName = Engine[0xED84C33EC5F01EA]( 0xB843BDD1B46759E ),
		longName = Engine[0xED84C33EC5F01EA]( 0xB8AD71B5FB7F656 ),
		longNamePlural = Engine[0xED84C33EC5F01EA]( 0x52987F0C95BEB91 )
	}
}
local f0_local2 = 0x6BE961B78280A7D
local f0_local3 = function ( f17_arg0, f17_arg1 )
	local f17_local0 = {}
	for f17_local1 = #f0_local0, 1, -1 do
		local f17_local4 = f0_local0[f17_local1]
		local f17_local5 = f17_arg1[f17_local4]
		if f17_local5 ~= nil then
			local f17_local6 = TIME.TimeFields[f17_local4]
			local f17_local7 = math.floor( f17_arg0 / f17_local6.milliseconds )
			f17_arg0 = f17_arg0 - f17_local7 * f17_local6.milliseconds
			if not (0 >= f17_local7 and (f17_local1 ~= 1 or f17_local7 ~= 0)) or f17_local5 == false then
				f17_local0[f17_local4] = f17_local7
			end
		end
	end
	return f17_local0
end

local f0_local4 = function ( f16_arg0 )
	for f16_local0 = #f0_local0, 1, -1 do
		local f16_local3 = f0_local0[f16_local0]
		local f16_local4 = TIME.TimeFields[f16_local3]
		local f16_local5 = math.floor( f16_arg0 / f16_local4.milliseconds )
		f16_arg0 = f16_arg0 - f16_local5 * f16_local4.milliseconds
		if 0 < f16_local5 or f16_local0 == 1 and f16_local5 == 0 then
			return {
				timeFieldName = f16_local3,
				timeFieldValue = f16_local5
			}
		end
	end
	return nil
end

local f0_local5 = function ( f15_arg0, f15_arg1 )
	local f15_local0 = f0_local0( f15_arg0, f15_arg1 )
	local f15_local1 = ""
	local f15_local2 = {}
	local f15_local3 = CONDITIONS.IsArabic( self )
	local f15_local4
	if f15_local3 then
		f15_local4 = f0_local0
		if not f15_local4 then
		
		else
			for f15_local5 = #f15_local4, 1, -1 do
				local f15_local8 = f15_local4[f15_local5]
				local f15_local9 = f15_local0[f15_local8]
				if f15_local9 then
					local f15_local10 = nil
					if f15_local3 then
						f15_local10 = string.format( "%s %d", 1 and TIME.TimeFields[f15_local8].longNamePlural or TIME.TimeFields[f15_local8].longName, f15_local9 )
					else
						f15_local10 = string.format( "%d %s", f15_local9, 1 and TIME.TimeFields[f15_local8].longNamePlural or TIME.TimeFields[f15_local8].longName )
					end
					table.insert( f15_local2, f15_local10 )
					f15_local1 = f15_local1 .. "%s "
				end
			end
			local f15_local5 = string.format
			local f15_local7 = f15_local1
			return f15_local5( unpack( f15_local2 ) )
		end
	end
	f15_local4 = f0_local0
end

local f0_local6 = function ( f14_arg0 )
	local f14_local0 = f0_local0( f14_arg0 )
	local f14_local1 = nil
	if CONDITIONS.IsArabic( self ) then
		local f14_local2 = string.format
		local f14_local3 = "%s %d"
		local f14_local4
		if 1 < f14_local0.timeFieldValue then
			f14_local4 = TIME.TimeFields[f14_local0.timeFieldName].longNamePlural
			if not f14_local4 then
			
			else
				f14_local1 = f14_local2( f14_local3, f14_local4, f14_local0.timeFieldValue )
			end
		end
		f14_local4 = TIME.TimeFields[f14_local0.timeFieldName].longName
	else
		local f14_local2 = string.format
		local f14_local3 = "%d %s"
		local f14_local4 = f14_local0.timeFieldValue
		local f14_local5
		if 1 < f14_local0.timeFieldValue then
			f14_local5 = TIME.TimeFields[f14_local0.timeFieldName].longNamePlural
			if not f14_local5 then
			
			else
				f14_local1 = f14_local2( f14_local3, f14_local4, f14_local5 )
			end
		end
		f14_local5 = TIME.TimeFields[f14_local0.timeFieldName].longName
	end
	local f14_local2 = Engine[0xED84C33EC5F01EA]
	local f14_local3 = f0_local0
	return f14_local2( Engine[0x7D3158A9539A355]( f14_local1 ) )
end

local f0_local7 = function ( f13_arg0, f13_arg1 )
	local f13_local0 = f0_local0( f13_arg0, f13_arg1 )
	local f13_local1 = ""
	local f13_local2 = {}
	local f13_local3 = CONDITIONS.IsArabic( self )
	local f13_local4 = f0_local0
	if f13_local3 then
		f13_local4 = f0_local0
	end
	if f13_arg1.timeFieldOrder then
		f13_local4 = f13_arg1.timeFieldOrder
	end
	for f13_local5 = #f13_local4, 1, -1 do
		local f13_local8 = f13_local4[f13_local5]
		local f13_local9 = f13_local0[f13_local8]
		if f13_local9 then
			local f13_local10 = nil
			if f13_local3 then
				f13_local10 = string.format( "%s%d", TIME.TimeFields[f13_local8].smallName, f13_local9 )
			else
				f13_local10 = string.format( "%d%s", f13_local9, TIME.TimeFields[f13_local8].smallName )
			end
			table.insert( f13_local2, f13_local10 )
			f13_local1 = f13_local1 .. "%s "
		end
	end
	local f13_local5 = string.format
	local f13_local7 = f13_local1
	return f13_local5( unpack( f13_local2 ) )
end

local f0_local8 = function ( f12_arg0 )
	local f12_local0 = f0_local0( f12_arg0 )
	local f12_local1 = nil
	if CONDITIONS.IsArabic( self ) then
		f12_local1 = string.format( "%s%d", TIME.TimeFields[f12_local0.timeFieldName].smallName, f12_local0.timeFieldValue )
	else
		f12_local1 = string.format( "%d%s", f12_local0.timeFieldValue, TIME.TimeFields[f12_local0.timeFieldName].smallName )
	end
	local f12_local2 = Engine[0xED84C33EC5F01EA]
	local f12_local3 = f0_local0
	return f12_local2( Engine[0x7D3158A9539A355]( f12_local1 ) )
end

local f0_local9 = function ( f11_arg0, f11_arg1 )
	return string.format( "%01d:%02d.%01d", f11_arg0 / 60000, f11_arg0 / 1000 % 60, f11_arg0 % 1000 / 100 )
end

local f0_local10 = function ( f10_arg0 )
	return string.format( "%01d:%02d", f10_arg0 / 60000, f10_arg0 / 1000 % 60 )
end

local f0_local11 = function ( f9_arg0, f9_arg1 )
	return string.format( "%02d:%02d:%02d", math.floor( f9_arg0 / 3600000 ), math.floor( f9_arg0 % 3600000 / 60000 ), math.floor( f9_arg0 % 60000 / 1000 ) )
end

local f0_local12 = function ( f8_arg0, f8_arg1 )
	return string.format( "%2d:%02d", math.floor( f8_arg0 / 3600000 ), math.floor( f8_arg0 % 3600000 / 60000 ) )
end

TIME.FormatSeconds = function ( f7_arg0, f7_arg1, f7_arg2 )
	if not f7_arg2 then
		f7_arg2 = {
			minute = false,
			second = false
		}
	end
	if f7_arg1 == TIME.Format.READABLE then
		return f0_local0( f7_arg0 * 1000, f7_arg2 )
	elseif f7_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f7_arg0 * 1000, f7_arg2 )
	elseif f7_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f7_arg0 * 1000 )
	elseif f7_arg1 == TIME.Format.STOPWATCH_MINIMAL then
		return f0_local0( f7_arg0 * 1000 )
	elseif f7_arg1 == TIME.Format.CLOCK then
		return f0_local0( f7_arg0 * 1000 )
	elseif f7_arg1 == TIME.Format.CLOCK_MINIMAL then
		return f0_local0( f7_arg0 * 1000 )
	else
		assert( false, "Invalid time format provided to TIME.FormatSeconds" )
	end
end

TIME.FormatMilliseconds = function ( f6_arg0, f6_arg1, f6_arg2 )
	if not f6_arg2 then
		f6_arg2 = {
			minute = false,
			second = false
		}
	end
	if f6_arg1 == TIME.Format.READABLE then
		return f0_local0( f6_arg0, f6_arg2 )
	elseif f6_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f6_arg0, f6_arg2 )
	elseif f6_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f6_arg0 )
	elseif f6_arg1 == TIME.Format.STOPWATCH_MINIMAL then
		return f0_local0( f6_arg0 )
	elseif f6_arg1 == TIME.Format.CLOCK then
		return f0_local0( f6_arg0 )
	else
		assert( false, "Invalid time format provided to TIME.FormatMilliseconds" )
	end
end

TIME.FormatSecondsAgo = function ( f5_arg0, f5_arg1 )
	if f5_arg1 == TIME.Format.READABLE then
		return f0_local0( f5_arg0 * 1000 )
	elseif f5_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f5_arg0 * 1000 )
	else
		assert( false, "Invalid time format provided to TIME.FormatSecondsAgo" )
	end
end

TIME.FormatMillisecondsAgo = function ( f4_arg0, f4_arg1 )
	if f4_arg1 == TIME.Format.READABLE then
		return f0_local0( f4_arg0 )
	elseif f4_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f4_arg0 )
	else
		assert( false, "Invalid time format provided to TIME.FormatMillisecondsAgo" )
	end
end

TIME.GetTimeTable = function ( f3_arg0 )
	return os.date( "*t", f3_arg0 )
end

TIME.IsDifferentDate = function ( f2_arg0, f2_arg1 )
	local f2_local0 = TIME.GetTimeTable( f2_arg0 )
	local f2_local1 = TIME.GetTimeTable( f2_arg1 )
	local f2_local2
	if f2_local0.day == f2_local1.day and f2_local0.month == f2_local1.month and f2_local0.year == f2_local1.year then
		f2_local2 = false
	else
		f2_local2 = true
	end
	return f2_local2
end

TIME.ConvertSecondsToMinutes = function ( f1_arg0, f1_arg1 )
	local f1_local0 = f1_arg0 / TIME.MINUTE
	if f1_arg1 then
		f1_local0 = Math.Round( f1_local0 )
	end
	return f1_local0
end

