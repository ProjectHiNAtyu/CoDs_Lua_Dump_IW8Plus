-- Generated by CoDLuaDecompiler
-- Version: 2.4.2
-- Date: 04-10-2025 21:43
REGISTRATION = REGISTRATION or {}
REGISTRATION.UserNameRulesConstants = {
	MAX_LENGTH = -63,
	MAX_GLYPHS_WITH_NUMBER = 24,
	MIN_LENGTH = 2,
	MAX_GLYPHS = 16,
	GLYPH_BYTE_LIMIT = 3,
	MIN_GLYPHS = 2
}
REGISTRATION.EmailRulesConstants = {
	MAX_LENGTH = 255,
	MIN_LENGTH = 5,
	REQUIRED_SYMBOLS = {
		nil,
		"@",
		"."
	}
}
REGISTRATION.PasswordRulesConstants = {
	MAX_SEQUENTIAL_GLYPHS = 2,
	MIN_LENGTH = 8,
	MAX_GLYPHS = 20,
	MAX_LENGTH = -48,
	MIN_GLYPHS = 8,
	MAX_CONSECUTIVE_GLYPHS = 2
}
REGISTRATION.OTPPasswordMaxValue = 999999
REGISTRATION.UserNameRuleIDs = {
	UTF8_SINGLE_GLYPH_BYTE_LIMIT = 3,
	UTF8_GLYPH_LIMIT = 4,
	ILLEGAL_CHARACTER = 2,
	LENGTH = 1
}
REGISTRATION.UserNameRules = {
	[REGISTRATION.UserNameRuleIDs.LENGTH] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/USERNAME_REQ_LENGTH", REGISTRATION.UserNameRulesConstants.MIN_GLYPHS, REGISTRATION.UserNameRulesConstants.MAX_GLYPHS )
		end
	},
	[REGISTRATION.UserNameRuleIDs.ILLEGAL_CHARACTER] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/USERNAME_REQ_SINGLE_GLYPH_LIMIT" )
		end
	},
	[REGISTRATION.UserNameRuleIDs.UTF8_SINGLE_GLYPH_BYTE_LIMIT] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/USERNAME_REQ_SINGLE_GLYPH_LIMIT" )
		end
	},
	[REGISTRATION.UserNameRuleIDs.UTF8_GLYPH_LIMIT] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/USERNAME_REQ_LENGTH", REGISTRATION.UserNameRulesConstants.MIN_GLYPHS, REGISTRATION.UserNameRulesConstants.MAX_GLYPHS )
		end
	}
}
REGISTRATION.EmailRuleIDs = {
	MUST_CONTAIN_SYMBOLS = 2,
	LENGTH = 1
}
REGISTRATION.EmailRules = {
	[REGISTRATION.EmailRuleIDs.LENGTH] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/EMAIL_REQ_LENGTH", REGISTRATION.EmailRulesConstants.MIN_LENGTH, REGISTRATION.EmailRulesConstants.MAX_LENGTH )
		end
	},
	[REGISTRATION.EmailRuleIDs.MUST_CONTAIN_SYMBOLS] = {
		isPassing = false,
		passingSymbols = {},
		GetLocalizedString = function ( f19_arg0 )
			local f19_local0 = ""
			local f19_local1 = 0
			for f19_local11, f19_local12 in ipairs( REGISTRATION.EmailRulesConstants.REQUIRED_SYMBOLS ) do
				local f19_local8 = false
				if f19_arg0 then
					for f19_local9, f19_local10 in ipairs( f19_arg0 ) do
						if f19_local12 == f19_local10 then
							f19_local8 = true
							break
						end
					end
				end
				if not f19_local8 then
					f19_local1 = f19_local1 + 1
					if 0 < #f19_local0 then
						f19_local0 = f19_local0 .. " " .. Engine[0xED84C33EC5F01EA]( "CODACCOUNT/AND" ) .. " "
					end
					f19_local0 = f19_local0 .. "\"" .. f19_local12 .. "\""
				end
			end
			f19_local2 = Engine[0xED84C33EC5F01EA]
			if 1 < f19_local1 then
				f19_local4 = "CODACCOUNT/EMAIL_REQ_SYMBOLS"
			else
				f19_local4 = "CODACCOUNT/EMAIL_REQ_SYMBOL"
			end
			return f19_local2( Engine[0x7D3158A9539A355]( f19_local0 ) )
		end
	}
}
REGISTRATION.PasswordRuleIDs = {
	CHAR_NUMBER = 2,
	SEQUENTIAL = 3,
	CONSECUTIVE = 4,
	LENGTH = 1
}
REGISTRATION.PasswordRules = {
	[REGISTRATION.PasswordRuleIDs.LENGTH] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/PASSWORD_REQ_LENGTH", REGISTRATION.PasswordRulesConstants.MIN_GLYPHS, REGISTRATION.PasswordRulesConstants.MAX_GLYPHS )
		end
	},
	[REGISTRATION.PasswordRuleIDs.CHAR_NUMBER] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/PASSWORD_REQ_CHAR_NUMBER" )
		end
	},
	[REGISTRATION.PasswordRuleIDs.SEQUENTIAL] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/PASSWORD_REQ_SEQUENTIAL" )
		end
	},
	[REGISTRATION.PasswordRuleIDs.CONSECUTIVE] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/PASSWORD_REQ_CONSECUTIVE" )
		end
	}
}
REGISTRATION.PasswordRulesLogin = {
	[REGISTRATION.PasswordRuleIDs.LENGTH] = {
		isPassing = false,
		GetLocalizedString = function ()
			return Engine[0xED84C33EC5F01EA]( "CODACCOUNT/PASSWORD_REQ_LENGTH", REGISTRATION.PasswordRulesConstants.MIN_GLYPHS, REGISTRATION.PasswordRulesConstants.MAX_GLYPHS )
		end
	}
}
REGISTRATION.IsASCIIByte = function ( f13_arg0 )
	return not Engine[0x77DA0DE401A96D0]( f13_arg0, 7 )
end

REGISTRATION.IsUTF8StartByte = function ( f12_arg0 )
	local f12_local0 = Engine[0x77DA0DE401A96D0]( f12_arg0, 7 )
	if f12_local0 then
		f12_local0 = Engine[0x77DA0DE401A96D0]( f12_arg0, 6 )
	end
	return f12_local0
end

REGISTRATION.CountUTF8Glyphs = function ( f11_arg0 )
	local f11_local0 = 0
	for f11_local1 = 1, #f11_arg0, 1 do
		local f11_local4 = f11_arg0:byte( f11_local1 )
		if REGISTRATION.IsASCIIByte( f11_local4 ) or REGISTRATION.IsUTF8StartByte( f11_local4 ) then
			f11_local0 = f11_local0 + 1
		end
	end
	return f11_local0
end

REGISTRATION.CheckInvalidUTF8GlyphLength = function ( f10_arg0 )
	local f10_local0 = false
	for f10_local1 = 1, #f10_arg0, 1 do
		if REGISTRATION.IsUTF8StartByte( f10_arg0:byte( f10_local1 ) ) then
			local f10_local4 = false
			for f10_local5 = f10_local1 + 1, f10_local1 + REGISTRATION.UserNameRulesConstants.GLYPH_BYTE_LIMIT, 1 do
				local f10_local8 = f10_arg0:byte( f10_local5 )
				if #f10_arg0 < f10_local5 or f10_local8 == 0 or REGISTRATION.IsASCIIByte( f10_local8 ) or REGISTRATION.IsUTF8StartByte( f10_local8 ) then
					f10_local4 = true
					break
				end
			end
			if not f10_local4 then
				f10_local0 = true
			end
		end
	end
	return f10_local0
end

REGISTRATION.CheckRulesOnUserName = function ( f9_arg0, f9_arg1 )
	local f9_local0 = #f9_arg0
	local f9_local1
	if f9_local0 < REGISTRATION.UserNameRulesConstants.MIN_LENGTH or f9_local0 >= REGISTRATION.UserNameRulesConstants.MAX_LENGTH then
		f9_local1 = false
	else
		f9_local1 = true
	end
	REGISTRATION.UserNameRules[REGISTRATION.UserNameRuleIDs.LENGTH].isPassing = f9_local1
	if not f9_arg1 then
		f9_arg1 = false
	end
	local f9_local2 = AccountRegistration[0x59A63ED9AD23C7A]( f9_arg0, f9_arg1 )
	REGISTRATION.UserNameRules[REGISTRATION.UserNameRuleIDs.ILLEGAL_CHARACTER].isPassing = f9_local2.legal
	REGISTRATION.UserNameRules[REGISTRATION.UserNameRuleIDs.UTF8_SINGLE_GLYPH_BYTE_LIMIT].isPassing = not REGISTRATION.CheckInvalidUTF8GlyphLength( f9_arg0 )
	local f9_local3 = REGISTRATION.CountUTF8Glyphs( f9_arg0 )
	local f9_local4
	if f9_local3 >= REGISTRATION.UserNameRulesConstants.MIN_GLYPHS then
		if f9_arg1 then
			f9_local4 = REGISTRATION.UserNameRulesConstants.MAX_GLYPHS_WITH_NUMBER
			if not f9_local4 then
			
			else
				if f9_local3 > f9_local4 then
					f9_local4 = false
				end
				f9_local4 = true
			end
		end
		f9_local4 = REGISTRATION.UserNameRulesConstants.MAX_GLYPHS
	end
	f9_local4 = false
end

REGISTRATION.CheckRulesOnEmail = function ( f8_arg0 )
	local f8_local0 = #f8_arg0
	local f8_local1
	if f8_local0 < REGISTRATION.EmailRulesConstants.MIN_LENGTH or f8_local0 >= REGISTRATION.EmailRulesConstants.MAX_LENGTH then
		f8_local1 = false
	else
		f8_local1 = true
	end
	REGISTRATION.EmailRules[REGISTRATION.EmailRuleIDs.LENGTH].isPassing = f8_local1
	local f8_local2 = {}
	local f8_local3 = {}
	if 0 < #REGISTRATION.EmailRulesConstants.REQUIRED_SYMBOLS then
		for f8_local4 = 1, f8_local0, 1 do
			local f8_local7 = f8_arg0:byte( f8_local4 )
			for f8_local11, f8_local12 in ipairs( REGISTRATION.EmailRulesConstants.REQUIRED_SYMBOLS ) do
				if f8_local7 == string.byte( f8_local12 ) then
					if not f8_local2[f8_local12] then
						table.insert( f8_local3, f8_local12 )
						f8_local2[f8_local12] = true
					end
				end
			end
		end
	end
	REGISTRATION.EmailRules[REGISTRATION.EmailRuleIDs.MUST_CONTAIN_SYMBOLS].isPassing = #f8_local3 == #REGISTRATION.EmailRulesConstants.REQUIRED_SYMBOLS
	REGISTRATION.EmailRules[REGISTRATION.EmailRuleIDs.MUST_CONTAIN_SYMBOLS].passingSymbols = f8_local3
end

REGISTRATION.CheckRulesOnPassword = function ( f7_arg0 )
	local f7_local0 = REGISTRATION.CountUTF8Glyphs( f7_arg0 )
	local f7_local1
	if f7_local0 < REGISTRATION.PasswordRulesConstants.MIN_GLYPHS or f7_local0 > REGISTRATION.PasswordRulesConstants.MAX_GLYPHS then
		f7_local1 = false
	else
		f7_local1 = true
	end
	REGISTRATION.PasswordRules[REGISTRATION.PasswordRuleIDs.LENGTH].isPassing = f7_local1
	local f7_local2 = 0
	for f7_local3 = 1, #f7_arg0, 1 do
		local f7_local6 = f7_arg0:byte( f7_local3 )
		if REGISTRATION.IsASCIIByte( f7_local6 ) and f7_local6 >= string.byte( "0" ) and f7_local6 <= string.byte( "9" ) then
			f7_local2 = f7_local2 + 1
		end
	end
	local f7_local3 = REGISTRATION.PasswordRules[REGISTRATION.PasswordRuleIDs.CHAR_NUMBER]
	if 0 >= f7_local2 or f7_local2 >= f7_local0 then
		f7_local4 = false
	else
		local f7_local4 = true
	end
	f7_local3.isPassing = f7_local4
	f7_local3 = -1
	f7_local4 = {}
	for f7_local5 = 1, #f7_arg0, 1 do
		local f7_local8 = f7_arg0:byte( f7_local5 )
		if REGISTRATION.IsASCIIByte( f7_local8 ) then
			table.insert( f7_local4, f7_local8 )
			f7_local3 = -1
		end
		if REGISTRATION.IsUTF8StartByte( f7_local8 ) then
			if f7_local3 ~= -1 then
				table.insert( f7_local4, f7_local3 )
			end
			f7_local3 = f7_local8
		end
		f7_local3 = f7_local3 + f7_local8
		if f7_local5 == #f7_arg0 then
			table.insert( f7_local4, f7_local3 )
		end
	end
	local f7_local5 = 0
	local f7_local7 = 0
	local f7_local6 = {
		Forward = 1,
		Reverse = 4294967295,
		None = 0
	}
	local f7_local9 = f7_local6.None
	local f7_local8 = 0
	local f7_local10 = 0
	local f7_local11 = 0
	for f7_local15, f7_local16 in ipairs( f7_local4 ) do
		if f7_local11 == f7_local16 + 1 then
			if f7_local9 <= f7_local6.None then
				f7_local5 = f7_local5 + 1
			end
			f7_local9 = f7_local6.Reverse
		elseif f7_local11 == f7_local16 - 1 then
			if f7_local6.None <= f7_local9 then
				f7_local5 = f7_local5 + 1
			end
			f7_local9 = f7_local6.Forward
		else
			f7_local5 = 0
			f7_local9 = f7_local6.None
		end
		if f7_local11 == f7_local16 then
			f7_local8 = f7_local8 + 1
		else
			f7_local8 = 0
		end
		f7_local7 = math.max( f7_local7, f7_local5 )
		f7_local10 = math.max( f7_local10, f7_local8 )
		f7_local11 = f7_local16
	end
	REGISTRATION.PasswordRules[REGISTRATION.PasswordRuleIDs.SEQUENTIAL].isPassing = f7_local7 < REGISTRATION.PasswordRulesConstants.MAX_SEQUENTIAL_GLYPHS
	REGISTRATION.PasswordRules[REGISTRATION.PasswordRuleIDs.CONSECUTIVE].isPassing = f7_local10 < REGISTRATION.PasswordRulesConstants.MAX_CONSECUTIVE_GLYPHS
end

REGISTRATION.CheckRulesOnPasswordLogin = function ( f6_arg0 )
	local f6_local0 = REGISTRATION.CountUTF8Glyphs( f6_arg0 )
	local f6_local1
	if f6_local0 < REGISTRATION.PasswordRulesConstants.MIN_GLYPHS or f6_local0 > REGISTRATION.PasswordRulesConstants.MAX_GLYPHS then
		f6_local1 = false
	else
		f6_local1 = true
	end
	REGISTRATION.PasswordRulesLogin[REGISTRATION.PasswordRuleIDs.LENGTH].isPassing = f6_local1
end

REGISTRATION.CheckIsPassing = function ( f5_arg0 )
	for f5_local3, f5_local4 in ipairs( f5_arg0 ) do
		if not f5_local4.isPassing then
			return false, f5_local4.GetLocalizedString( f5_local4.passingSymbols )
		end
	end
	return true
end

REGISTRATION.UpdateUserName = function ( f4_arg0, f4_arg1 )
	REGISTRATION.CheckRulesOnUserName( f4_arg0, f4_arg1 )
end

REGISTRATION.UpdateEmail = function ( f3_arg0 )
	REGISTRATION.CheckRulesOnEmail( f3_arg0 )
end

REGISTRATION.UpdatePassword = function ( f2_arg0 )
	REGISTRATION.CheckRulesOnPassword( f2_arg0 )
end

REGISTRATION.UpdatePasswordLogin = function ( f1_arg0 )
	REGISTRATION.CheckRulesOnPasswordLogin( f1_arg0 )
end

