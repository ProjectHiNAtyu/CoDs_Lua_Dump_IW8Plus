-- Generated by CoDLuaDecompiler
-- Version: 2.4.2
-- Date: 13-10-2025 14:16
Math = Math or {}
Math.M_PI = 3.141592653589793
Math.Clamp = function ( f9_arg0, f9_arg1, f9_arg2 )
	if f9_arg0 < f9_arg1 then
		return f9_arg1
	elseif f9_arg2 < f9_arg0 then
		return f9_arg2
	else
		return f9_arg0
	end
end

Math.Lerp = function ( f8_arg0, f8_arg1, f8_arg2 )
	return f8_arg0 + f8_arg2 * (f8_arg1 - f8_arg0)
end

Math.InvLerp = function ( f7_arg0, f7_arg1, f7_arg2 )
	assert( f7_arg1 ~= f7_arg0 )
	return Math.Clamp( (f7_arg2 - f7_arg0) / (f7_arg1 - f7_arg0), 0, 1 )
end

Math.Remap = function ( f6_arg0, f6_arg1, f6_arg2, f6_arg3, f6_arg4 )
	return Math.Lerp( f6_arg2, f6_arg3, Math.InvLerp( f6_arg0, f6_arg1, f6_arg4 ) )
end

Math.Round = function ( f5_arg0, f5_arg1 )
	local f5_local0
	if not f5_arg1 then
		f5_local0 = f5_arg1
	else
		f5_local0 = 0
	end
	f5_local0 = 10 ^ f5_local0
	return math.floor( f5_arg0 * f5_local0 + 0.5 ) / f5_local0
end

Math.IsNaN = function ( f4_arg0 )
	if type( f4_arg0 ) ~= "number" then
		assert( type( f4_arg0 ) ~= "number" )
		return false
	else
		return f4_arg0 ~= f4_arg0
	end
end

Math.IsInfinite = function ( f3_arg0 )
	if type( f3_arg0 ) ~= "number" then
		assert( type( f3_arg0 ) ~= "number" )
		return false
	else
		local f3_local0
		if math.huge ~= x and -math.huge ~= x then
			f3_local0 = false
		else
			f3_local0 = true
		end
	end
	return f3_local0
end

Math.Vec3Assign = function ( f2_arg0, f2_arg1 )
	assert( type( f2_arg0 ) == "table" )
	assert( type( f2_arg1 ) == "table" )
	f2_arg1.x = f2_arg0.x
	f2_arg1.y = f2_arg0.y
	f2_arg1.z = f2_arg0.z
	return f2_arg1
end

Math.Vec3Sub = function ( f1_arg0, f1_arg1, f1_arg2 )
	assert( type( f1_arg0 ) == "table" )
	assert( type( f1_arg1 ) == "table" )
	assert( type( f1_arg2 ) == "table" )
	f1_arg2.x = f1_arg0.x - f1_arg1.x
	f1_arg2.y = f1_arg0.y - f1_arg1.y
	f1_arg2.z = f1_arg0.z - f1_arg1.z
	return f1_arg2
end

