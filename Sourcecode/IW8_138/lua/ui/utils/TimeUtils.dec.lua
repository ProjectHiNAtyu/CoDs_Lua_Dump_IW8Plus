-- Generated by CoDLuaDecompiler
-- Version: 2.4.2
-- Date: 02-09-2025 10:42
TIME = {
	Format = {
		STOPWATCH = 3,
		READABLE = 1,
		READABLE_MINIMAL = 2
	},
	TIMER_TICK = "timer_tick",
	TIMER_COMPLETE = "timer_complete"
}
local f0_local0 = {
	nil,
	"millisecond",
	"second",
	"minute",
	"hour",
	"day"
}
local f0_local1 = {
	nil,
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
}
local f0_local2 = {
	millisecond = {
		milliseconds = 1,
		smallName = Engine.CBBHFCGDIC( "TIME/MILLISECOND_MINIMAL" ),
		longName = Engine.CBBHFCGDIC( "TIME/MILLISECOND" ),
		longNamePlural = Engine.CBBHFCGDIC( "TIME/MILLISECOND_PLURAL" )
	},
	second = {
		milliseconds = 1000,
		smallName = Engine.CBBHFCGDIC( "TIME/SECOND_MINIMAL" ),
		longName = Engine.CBBHFCGDIC( "TIME/SECOND" ),
		longNamePlural = Engine.CBBHFCGDIC( "TIME/SECOND_PLURAL" )
	},
	minute = {
		milliseconds = 60000,
		smallName = Engine.CBBHFCGDIC( "TIME/MINUTE_MINIMAL" ),
		longName = Engine.CBBHFCGDIC( "TIME/MINUTE" ),
		longNamePlural = Engine.CBBHFCGDIC( "TIME/MINUTE_PLURAL" )
	},
	hour = {
		milliseconds = 3600000,
		smallName = Engine.CBBHFCGDIC( "TIME/HOUR_MINIMAL" ),
		longName = Engine.CBBHFCGDIC( "TIME/HOUR" ),
		longNamePlural = Engine.CBBHFCGDIC( "TIME/HOUR_PLURAL" )
	},
	day = {
		milliseconds = 86400000,
		smallName = Engine.CBBHFCGDIC( "TIME/DAY_MINIMAL" ),
		longName = Engine.CBBHFCGDIC( "TIME/DAY" ),
		longNamePlural = Engine.CBBHFCGDIC( "TIME/DAY_PLURAL" )
	}
}
local f0_local3 = function ( f8_arg0, f8_arg1 )
	local f8_local0 = {}
	for f8_local1 = #f0_local0, 1, -1 do
		local f8_local4 = f0_local0[f8_local1]
		local f8_local5 = f8_arg1[f8_local4]
		if f8_local5 ~= nil then
			local f8_local6 = f0_local0[f8_local4]
			local f8_local7 = math.floor( f8_arg0 / f8_local6.milliseconds )
			f8_arg0 = f8_arg0 - f8_local7 * f8_local6.milliseconds
			if 0 < f8_local7 or f8_local5 == false then
				f8_local0[f8_local4] = f8_local7
			end
		end
	end
	return f8_local0
end

local f0_local4 = function ( f7_arg0, f7_arg1 )
	local f7_local0 = f0_local0( f7_arg0, f7_arg1 )
	local f7_local1 = ""
	local f7_local2 = {}
	local f7_local3 = CONDITIONS.IsArabic( self )
	local f7_local4
	if f7_local3 then
		f7_local4 = f0_local0
		if not f7_local4 then
		
		else
			for f7_local5 = #f7_local4, 1, -1 do
				local f7_local8 = f7_local4[f7_local5]
				local f7_local9 = f7_local0[f7_local8]
				if f7_local9 then
					local f7_local10 = nil
					if f7_local3 then
						f7_local10 = string.format( "%s %d", 1 and f0_local0[f7_local8].longNamePlural or f0_local0[f7_local8].longName, f7_local9 )
					else
						f7_local10 = string.format( "%d %s", f7_local9, 1 and f0_local0[f7_local8].longNamePlural or f0_local0[f7_local8].longName )
					end
					table.insert( f7_local2, f7_local10 )
					f7_local1 = f7_local1 .. "%s "
				end
			end
			local f7_local5 = string.format
			local f7_local7 = f7_local1
			return f7_local5( unpack( f7_local2 ) )
		end
	end
	f7_local4 = f0_local0
end

TIME.SetCountDownTimerTextField = function ( f5_arg0, f5_arg1, f5_arg2 )
	local f5_local0 = assert
	local self
	if f5_arg0 then
		self = f5_arg0
	else
		self = f5_arg0.setText
	end
	f5_local0( self, " You must provide a valid Textfield element." )
	f5_local0 = assert
	if f5_arg1 then
		self = f5_arg1
	elseif type( f5_arg1 ) ~= "number" or 0 >= f5_arg1 then
		self = false
	else
		self = true
	end
	f5_local0( self, "You must provide a vaild number (in milliseconds greater than 0)" )
	if f5_arg2 then
		local f5_local2 = f5_arg2.customFormatString
		local f5_local3 = f5_arg2.customFormatString
	end
	f5_local0 = f5_local2 and f5_local3 or "LUA_MENU/DAYS_HOURS_MINUTES_SECONDS"
	if f5_arg2 then
		local f5_local4 = f5_arg2.customInterval
		local f5_local5 = f5_arg2.customInterval
	end
	self = LUI.UITimer.new( {
		interval = f5_local4 and f5_local5 or 1000,
		event = f5_arg0.id .. "_timer_tick"
	} )
	local f5_local6 = function ( f6_arg0, f6_arg1 )
		local f6_local0 = Engine.CCEJJCCDEG( tostring( f5_arg0 ) )
		if 0 < f6_local0 then
			local f6_local1 = math.floor( f6_local0 / 86400 )
			local f6_local2 = math.floor( f6_local0 % 86400 / 3600 )
			local f6_local3 = math.floor( f6_local0 % 3600 / 60 )
			local f6_local4 = math.floor( f6_local0 % 60 )
			if f5_arg0 and f5_arg0.useCustomDisplay then
				f6_arg0:processEvent( {
					name = TIME.TIMER_TICK,
					intervals = {
						days = f6_local1,
						hours = f6_local2,
						minutes = f6_local3,
						seconds = f6_local4
					}
				} )
			else
				f6_arg0:setText( Engine.CBBHFCGDIC( f5_arg0, f6_local1, f6_local2, f6_local3, f6_local4 ) )
			end
		else
			if f5_arg0 then
				f5_arg0:closeTree()
				f5_arg0 = nil
			end
			if f5_arg0 and f5_arg0.broadcastOnComplete then
				f5_arg0:processEvent( {
					name = TIME.TIMER_COMPLETE,
					[1] = {
						disabledText = f5_arg0.disabledText
					}
				} )
			else
				f6_arg0:setText( "" )
			end
		end
	end
	
	self.id = "countDownTimer"
	f5_arg0:addElement( self )
	f5_arg0:registerEventHandler( f5_arg0.id .. "_timer_tick", f5_local6 )
	f5_local6( f5_arg0 )
end

local f0_local5 = function ( f4_arg0, f4_arg1 )
	local f4_local0 = f0_local0( f4_arg0, f4_arg1 )
	local f4_local1 = ""
	local f4_local2 = {}
	local f4_local3 = CONDITIONS.IsArabic( self )
	local f4_local4
	if f4_local3 then
		f4_local4 = f0_local0
		if not f4_local4 then
		
		else
			for f4_local5 = #f4_local4, 1, -1 do
				local f4_local8 = f4_local4[f4_local5]
				local f4_local9 = f4_local0[f4_local8]
				if f4_local9 then
					local f4_local10 = nil
					if f4_local3 then
						f4_local10 = string.format( "%s%d", f0_local0[f4_local8].smallName, f4_local9 )
					else
						f4_local10 = string.format( "%d%s", f4_local9, f0_local0[f4_local8].smallName )
					end
					table.insert( f4_local2, f4_local10 )
					f4_local1 = f4_local1 .. "%s "
				end
			end
			local f4_local5 = string.format
			local f4_local7 = f4_local1
			return f4_local5( unpack( f4_local2 ) )
		end
	end
	f4_local4 = f0_local0
end

local f0_local6 = function ( f3_arg0, f3_arg1 )
	return string.format( "%01d:%02d.%01d", f3_arg0 / 60000, f3_arg0 / 1000 % 60, f3_arg0 % 1000 / 100 )
end

TIME.FormatSeconds = function ( f2_arg0, f2_arg1, f2_arg2 )
	if not f2_arg2 then
		f2_arg2 = {
			minute = false,
			second = false
		}
	end
	if f2_arg1 == TIME.Format.READABLE then
		return f0_local0( f2_arg0 * 1000, f2_arg2 )
	elseif f2_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f2_arg0 * 1000, f2_arg2 )
	elseif f2_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f2_arg0 * 1000 )
	else
		assert( false, "Invalid time format provided to TIME.FormatSeconds" )
	end
end

TIME.FormatMilliseconds = function ( f1_arg0, f1_arg1, f1_arg2 )
	if not f1_arg2 then
		f1_arg2 = {
			minute = false,
			second = false
		}
	end
	if f1_arg1 == TIME.Format.READABLE then
		return f0_local0( f1_arg0, f1_arg2 )
	elseif f1_arg1 == TIME.Format.READABLE_MINIMAL then
		return f0_local0( f1_arg0, f1_arg2 )
	elseif f1_arg1 == TIME.Format.STOPWATCH then
		return f0_local0( f1_arg0 )
	else
		assert( false, "Invalid time format provided to TIME.FormatMilliseconds" )
	end
end

